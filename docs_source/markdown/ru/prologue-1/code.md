Да, теоретически, если вы работаете на какой-то нетривиальной архитектуре, может потребоваться в явном виде портировать туда rustc. Однако, если архитектура настолько нетривиальна - есть немалая вероятность, что на неё не существует даже LLVM, а следовательно, rustc будет в любом случае бессилен. А для более стандартных случаев, как правило, рабочий вариант уже имеется в нашем распоряжении.
Используйте `rustup`. Не будьте такими, как Алекс.

Что же до кода - в этом эпизоде я старался максимально проиллюстрировать те элементы Rust, которые позиционируются как его сильные стороны: "бесстрашная конкурентность", модульная структура, строгая типизация всего и вся, - и в то же время не забыть и о том, что в некоторых случаях приходится - _осознанно_ и _дозированно_ - отступать в область `unsafe`:

```rust
#!/bin/rust

#![rust_attr]

fn receive() {
    // ...
}
```